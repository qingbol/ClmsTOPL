#!/usr/bin/python

import os, sys
import fnmatch
import subprocess
import filecmp

def testCode( retcode, msg ):
    if retcode > 0:
        print msg
        sys.exit( 1 )

testDir = os.path.join( os.getcwd(), 'cases')
if not os.path.isdir( testDir ):
    print testDir, "isn't a directory"
    sys.exit( 1 )

executable = os.path.join(os.getcwd(), "run")
if not os.path.isfile( executable ):
    retcode = subprocess.call("make",shell=True)
    testCode( retcode, "\tFAILED to make the scanner" )

# calculate the number of testcases
cnt = 0
# calculate the number of failed testcases
fail = 0

# get all files in testDir
files = os.listdir( testDir )
for x in files:
    if fnmatch.fnmatch(x, "*.py"):
        testcase = os.path.join(testDir, x)
        # using file "./run" to execute all test cases and output results to file "/tmp/run_output"
        runretcode = subprocess.call("./run < "+testcase+"> /tmp/run_output",shell=True)
        # using python to execute all test cases and output results to file "/tmp/py_output"
        # pyretcode = subprocess.call("brewpy2 < "+testcase+"> /tmp/py_output",shell=True)
        pyretcode = subprocess.call("python < "+testcase+"> /tmp/py_output",shell=True)
        
        # check the python file is correct or not 
        if pyretcode != 0:
            testCode( pyretcode, " wrong test case "+x)
        else:

            # compare the two outputs
            runfile = open("/tmp/run_output", "r")
            pyfile = open("/tmp/py_output", "r")
      
            runouts = runfile.readlines();
            pyouts = pyfile.readlines();
            # compare the length of the two outputs
            # because the results from execution of file "./run" contain "Program syntactically correct"
            # the correct length of this outputs should be greater than the output generated by python by one
            if len(runouts) != len(pyouts):
            # if len(runouts) != len(pyouts) + 1 :
                print x, " The line number is different, failed.||runouts is ", len(runouts), "|| pyouts is", len(pyouts) 
            else :
                
                # true : means the testcases contained in the file passed
                # false : means certain testcases contained in the file failed
                suc =True
                
                for i in range(0, len(pyouts)):
                    # add one to the number of all testcases
                    cnt += 1
                    
                    # true : means the one passed
                    # false : means the one failed
                    iSuc = True
                    
                    # print runouts[i],pyouts[i]
                    
                    # get the answer from the result generated by file "./run"
                    value1 = runouts[i].split(":")[1].replace(" ","").replace("\n","")
                    
                    # get rid of the char "\n"
                    value2 = pyouts[i].replace("\n","")
                    
                    if runouts[i].split(":")[0] == "FLOAT" :
                         # in mypy, the float value of a integer will output like a int,
                        # but in python, the float value of a integer will contain ".0"
                        # such as, the float number 4.0 in mypy will output 4, 
                        # but in python it will output 4.0
                        # So, I need to transfer this value into float first 
                        # and then transfer the value into a string for comparing.
                        value1 = str(float(value1))
                    
                    len1 = len(value1)
                    len2 = len(value2)
                    len_min = min(len1, len2)
                    if iSuc == True :
                        # compare the two strings one number by one
                        
                        # the position of failed index 
                        pos = -1
                        for j in range(0, len_min) :
                            if value1[j] != value2[j] :
                                pos = j 
                                break
                        if pos == -1 :
                            # the two strings is same in python precision.
                            iSuc = True
                        else :
                            # in python precision, the last number may be a result rounded by the next number
                            if pos < len2-1 :
                                # the falied index is not the last number, so the result is not correct.
                                iSuc = False
                            else :
                                # the failed index is the last number
                                if len1 == len2 :
                                    # no possible carry
                                    iSuc = False
                                else :
                                    if value1[pos + 1] >= '5' and  value2[pos] - value1[pos] == 1 :
                                        # the carry made the answer
                                        iSuc = True
                                    else :
                                        # no carry found to get the right anwer.
                                        iSuc = False

                    # if iSuc is False, then the file should set to False.
                    if iSuc == False :
                        suc = False
                        fail += 1
                        print i, "line in ",x , "|| ./run value is ", value1, "||python value is ", value2


                # output the results
                if suc == False :
                    print x, "some cases failed."
                else :
                    print x, "successed."

# print out the number of test case failed and all of them.
print "Results: ",cnt-fail,"/",cnt
